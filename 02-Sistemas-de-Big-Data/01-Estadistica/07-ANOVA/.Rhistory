max_price_zoning <- data %>%
group_by(data$MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
} else {
print("La columna de precio no se encontró en el dataset. Verifica el nombre de la columna.")
}
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
max_price_zoning <- data %>%
group_by(MSZONING) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZONING, data = data, FUN = mean)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZoning, data = data, FUN = mean)
View(average_prices)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
View(sorted_data)
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
View(most_expensive_zoning)
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
data_long <-melt(data, measure=c("Norte", "Sur", "Este","Oeste", "Centro"))
#La función melt() de R, que se encuentra en los paquetes reshape2 o data.table, se usa para transformar un conjunto de datos de formato ancho (wide) a formato largo (long). En tu caso, parece que tienes varias columnas que representan diferentes regiones (como "Norte", "Sur", "Este", "Oeste", "Centro") y quieres convertir esas columnas en una única columna con un formato más largo.
ggplot(data_long, aes(x=variable, y=value,
fill=variable))+
geom_boxplot()
#sacamos un resumencito
require("dplyr")
group_by(data_long, variable) %>%
summarise(
count = n(),
mean = mean(value),
sd = sd(value) )
setwd("~/01_CODE/___AI-BIG-DATA___/02-Sistemas-de-Big-Data/01-Estadistica/07-ANOVA/carne_conducir.txt")
data <- read.csv("carne_conducir.txt", sep="&")
data
#visualizamos
library(reshape2)
library(ggplot2)
data_long <-melt(data, measure=c("Norte", "Sur", "Este","Oeste", "Centro"))
#La función melt() de R, que se encuentra en los paquetes reshape2 o data.table, se usa para transformar un conjunto de datos de formato ancho (wide) a formato largo (long). En tu caso, parece que tienes varias columnas que representan diferentes regiones (como "Norte", "Sur", "Este", "Oeste", "Centro") y quieres convertir esas columnas en una única columna con un formato más largo.
ggplot(data_long, aes(x=variable, y=value,
fill=variable))+
geom_boxplot()
#sacamos un resumencito
require("dplyr")
group_by(data_long, variable) %>%
summarise(
count = n(),
mean = mean(value),
sd = sd(value) )
#sospechamos del centro y hacemos anova
#el objetivo es comparar las medias de los valores de la variable value en función de los diferentes niveles de la variable variable.
res.aov <- aov(value ~ variable, data_long )
View(res.aov)
summary(res.aov)
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZONING, data = data)
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
# Cargar los datos
data <- read.csv("trainmod.csv")
# Verificar nombres de columnas
print(names(data))
# Realizar ANOVA si la columna SalePrice existe
if ("SalePrice" %in% names(data) && "MSZoning" %in% names(data)) {
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
} else {
print("Las columnas SalePrice o MSZoning no se encuentran en el dataset.")
}
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
setwd("~/01_CODE/___AI-BIG-DATA___/02-Sistemas-de-Big-Data/01-Estadistica/07-ANOVA/carne_conducir.txt")
data <- read.csv("carne_conducir.txt", sep="&")
data
#visualizamos
library(reshape2)
library(ggplot2)
data_long <-melt(data, measure=c("Norte", "Sur", "Este","Oeste", "Centro"))
#La función melt() de R, que se encuentra en los paquetes reshape2 o data.table, se usa para transformar un conjunto de datos de formato ancho (wide) a formato largo (long). En tu caso, parece que tienes varias columnas que representan diferentes regiones (como "Norte", "Sur", "Este", "Oeste", "Centro") y quieres convertir esas columnas en una única columna con un formato más largo.
ggplot(data_long, aes(x=variable, y=value,
fill=variable))+
geom_boxplot()
#sacamos un resumencito
require("dplyr")
group_by(data_long, variable) %>%
summarise(
count = n(),
mean = mean(value),
sd = sd(value) )
#sospechamos del centro y hacemos anova
#el objetivo es comparar las medias de los valores de la variable value en función de los diferentes niveles de la variable variable.
res.aov <- aov(value ~ variable, data_long )
summary(res.aov)
#efectivamente rechamoz ho, vamos a ver d?nde esta la diferencia con tueky
TukeyHSD(res.aov)
View(data)
View(sorted_data)
setwd("~/01_CODE/___AI-BIG-DATA___/02-Sistemas-de-Big-Data/01-Estadistica/07-ANOVA/carne_conducir.txt")
data <- read.csv("carne_conducir.txt", sep="&")
data
#visualizamos
library(reshape2)
library(ggplot2)
data_long <-melt(data, measure=c("Norte", "Sur", "Este","Oeste", "Centro"))
#La función melt() de R, que se encuentra en los paquetes reshape2 o data.table, se usa para transformar un conjunto de datos de formato ancho (wide) a formato largo (long). En tu caso, parece que tienes varias columnas que representan diferentes regiones (como "Norte", "Sur", "Este", "Oeste", "Centro") y quieres convertir esas columnas en una única columna con un formato más largo.
ggplot(data_long, aes(x=variable, y=value,
fill=variable))+
geom_boxplot()
#sacamos un resumencito
require("dplyr")
group_by(data_long, variable) %>%
summarise(
count = n(),
mean = mean(value),
sd = sd(value) )
#sospechamos del centro y hacemos anova
#el objetivo es comparar las medias de los valores de la variable value en función de los diferentes niveles de la variable variable.
res.aov <- aov(value ~ variable, data_long )
summary(res.aov)
rm(list=ls())
# 1. Cargar los datos de “trainmod”.
data = read.csv("trainmod.csv")
head(data)
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZoning, data = data, FUN = mean)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
print(names(data))
data
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ Neighborhood, data = data, FUN = mean)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ Neighborhood, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
data$Neighborhood
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZoning, data = data, FUN = mean)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
View(most_expensive_zoning)
View(anova_result)
View(average_prices)
View(average_prices)
View(most_expensive_zoning)
# 6.1 Crear una nueva columna que clasifique antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YearSold < 2008, "Antes de la crisis", "Después de la crisis")
rm(list=ls())
# 1. Cargar los datos de “trainmod”.
data = read.csv("trainmod.csv")
head(data)
print(names(data))
data$Neighborhood
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
rm(list=ls())
# 1. Cargar los datos de “trainmod”.
data = read.csv("trainmod.csv")
head(data)
print(names(data))
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZoning, data = data, FUN = mean)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
ggplot(data, aes(x=variable, y=value,
fill=variable))+
geom_boxplot()
ggplot(data, aes(x=MSZoning, y=SalePrice,
fill=variable))+
geom_boxplot()
ggplot(data, aes(x=MSZoning, y=SalePrice,
fill=MSZoning))+
geom_boxplot()
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
# 6.1 Crear una nueva columna que clasifique antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YearSold < 2008, "Antes de la crisis", "Después de la crisis")
names(data)
# 6.1 Crear una nueva columna que clasifique antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.2 Calcular el precio promedio en cada período
library(dplyr)
average_prices <- data %>%
group_by(CrisisPeriod) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE))
print(average_prices)
# 6.3 Realizar una prueba t para comparar los precios antes y después de la crisis
before_crisis <- data$SalePrice[data$CrisisPeriod == "Antes de la crisis"]
after_crisis <- data$SalePrice[data$CrisisPeriod == "Después de la crisis"]
t_test_result <- t.test(before_crisis, after_crisis)
print(t_test_result)
print(average_prices)
names(data)
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
rm(list=ls())
# 1. Cargar los datos de “trainmod”.
data = read.csv("trainmod.csv")
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZoning, data = data, FUN = mean)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
ggplot(data, aes(x=MSZoning, y=SalePrice,
fill=MSZoning))+
geom_boxplot()
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.1 Crear una nueva columna que clasifique las ventas antes y después de la crisis
data$CrisisPeriod <- ifelse(data$YrSold < 2008, "Antes de la crisis", "Después de la crisis")
# 6.2 Calcular el precio promedio de las casas en cada período
library(dplyr)
average_prices <- data %>%
group_by(CrisisPeriod) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE))
# 6.3 Imprimir los resultados de los precios promedio
print("Precios promedio en cada período:")
print(average_prices)
# 7.1 Dividir los precios en dos grupos: antes y después de la crisis
before_crisis <- data$SalePrice[data$CrisisPeriod == "Antes de la crisis"]
after_crisis <- data$SalePrice[data$CrisisPeriod == "Después de la crisis"]
# 7.2 Realizar la prueba t para evaluar si la diferencia es significativa
t_test_result <- t.test(before_crisis, after_crisis)
# 7.3 Imprimir el resultado de la prueba t
print("Resultados de la prueba t:")
print(t_test_result)
# 7.4 Interpretación del valor p
if (t_test_result$p.value < 0.05) {
print("El valor p es menor que 0.05, lo que indica una diferencia estadísticamente significativa entre los precios antes y después de la crisis.")
} else {
print("El valor p es mayor que 0.05, lo que indica que no hay suficiente evidencia para afirmar que los precios de las casas son diferentes entre los dos períodos.")
}
# Imprimir solo el valor p
p_value <- t_test_result$p.value
print(p_value)
# 7.4 Interpretación del valor p
if (t_test_result$p.value < 0.05) {
print("El valor p es menor que 0.05, lo que indica una diferencia estadísticamente significativa entre los precios antes y después de la crisis.")
} else {
print("El valor p es mayor que 0.05, lo que indica que no hay suficiente evidencia para afirmar que los precios de las casas son diferentes entre los dos períodos.")
}
anova_result <- aov(SalePrice ~ Neighborhood, data = data)
summary(anova_result)
TukeyHSD(anova_result)
anova_result <- aov(SalePrice ~ Neighborhood, data = data)
summary(anova_result)
# Realizar el análisis de Tukey
tukey_result <- TukeyHSD(anova_result)
View(tukey_result)
# Extraer el resultado del análisis de Tukey para la variable Neighborhood
tukey_neighborhood <- tukey_result$Neighborhood
View(tukey_neighborhood)
# Convertir el resultado en un data frame para facilitar el filtrado
tukey_df <- as.data.frame(tukey_neighborhood)
# Filtrar los barrios con un valor p mayor que 0.05
tukey_filtered <- tukey_df[tukey_df$p.adj > 0.05, ]
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Realizar el análisis de Tukey
tukey_result <- TukeyHSD(anova_result)
# Extraer el resultado del análisis de Tukey para la variable Neighborhood
tukey_neighborhood <- tukey_result$Neighborhood
# Convertir el resultado en un data frame para facilitar el filtrado
tukey_df <- as.data.frame(tukey_neighborhood)
# Filtrar los barrios con un valor p mayor que 0.05
tukey_filtered <- tukey_df[tukey_df$p.adj > 0.05, ]
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
anova_result <- aov(SalePrice ~ Neighborhood, data = data)
summary(anova_result)
# Realizar el análisis de Tukey
tukey_result <- TukeyHSD(anova_result)
# Extraer el resultado del análisis de Tukey para la variable Neighborhood
tukey_neighborhood <- tukey_result$Neighborhood
# Convertir el resultado en un data frame para facilitar el filtrado
tukey_df <- as.data.frame(tukey_neighborhood)
# Filtrar los barrios con un valor p mayor que 0.05
tukey_filtered <- tukey_df[tukey_df$p.adj > 0.05, ]
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Realizar el ANOVA para comparar los precios en diferentes barrios
anova_result <- aov(SalePrice ~ Neighborhood, data = data)
summary(anova_result)
# Realizar el análisis de Tukey
tukey_result <- TukeyHSD(anova_result)
# Extraer el resultado del análisis de Tukey para la variable Neighborhood
tukey_neighborhood <- tukey_result$Neighborhood
# Convertir el resultado en un data frame para facilitar el filtrado
tukey_df <- as.data.frame(tukey_neighborhood)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, p.adj > 0.05)
# Realizar el ANOVA para comparar los precios en diferentes barrios
anova_result <- aov(SalePrice ~ Neighborhood, data = data)
summary(anova_result)
# Realizar el análisis de Tukey
tukey_result <- TukeyHSD(anova_result)
# Extraer el resultado del análisis de Tukey para la variable Neighborhood
tukey_neighborhood <- tukey_result$Neighborhood
# Convertir el resultado en un data frame para facilitar el filtrado
tukey_df <- as.data.frame(tukey_neighborhood)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, p.adj > 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, p.adj > 0.05)
names(tukey_df)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, p adj > 0.05)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, `p adj` > 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, "p adj" > 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, `p adj` > 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, `p adj` < 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
>
>
# Filtrar los barrios con un valor p ajustado mayor que 0.05
tukey_filtered <- subset(tukey_df, `p adj` > 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias no significativas (p > 0.05):")
print(tukey_filtered)
# Filtrar los barrios con un valor p ajustado menor que 0.05
tukey_filtered <- subset(tukey_df, `p adj` < 0.05)
# Mostrar los resultados filtrados
print("Barrios con diferencias significativas (p < 0.05):")
print(tukey_filtered)
rm(list=ls())
# 1. Cargar los datos de “trainmod”.
data = read.csv("trainmod.csv")
# 2. Determinar cuál es el MSZONING más caro
library(dplyr)
# Opción A
# 2A.1 Calcular el precio promedio por cada tipo de MSZONING
average_prices <- aggregate(SalePrice ~ MSZoning, data = data, FUN = mean)
# 2A.2 Ordenar los resultados en orden descendente de precio promedio
sorted_data <- average_prices[order(-average_prices$SalePrice), ]
# 2A.3 Seleccionar el primer elemento (MSZONING con el precio promedio más alto)
most_expensive_zoning <- sorted_data[1, ]
# 2A.4 Imprimir el resultado
print(most_expensive_zoning)
# Opción B
max_price_zoning <- data %>%
group_by(MSZoning) %>%
summarise(AveragePrice = mean(SalePrice, na.rm = TRUE)) %>%
arrange(desc(AveragePrice)) %>%
slice(1)
print(max_price_zoning)
ggplot(data, aes(x=MSZoning, y=SalePrice,
fill=MSZoning))+
geom_boxplot()
# Realizamo ANOVA para analizar las diferencias en SalePrice según MSZONING
anova_result <- aov(SalePrice ~ MSZoning, data = data)
summary(anova_result)
# 4. Comprobar si todas las zonas son significativamente diferentes.
TukeyHSD(anova_result)
# Realizar la prueba de Tukey
tukey_result <- TukeyHSD(anova_result)
# Extraer el resultado del análisis de Tukey para MSZoning
tukey_zones <- tukey_result$MSZoning
# Convertir el resultado en un data frame para facilitar el filtrado
tukey_df <- as.data.frame(tukey_zones)
# Filtrar las comparaciones con un valor p ajustado mayor que 0.05
tukey_non_significant <- subset(tukey_df, `p adj` > 0.05)
# Mostrar los resultados filtrados
print("Zonas que no son significativamente diferentes (p > 0.05):")
print(tukey_non_significant)
